# Go Gorutines

## For exampple
```
package main

import "fmt"

func main() {
	for i := 0; i < 5; i++ {
		go func() {
			fmt.Println(i)
		}()
	}
}

```

### часче всего люди думают что у нас значит цико вертитса и  в одельной горутине мы запускаем пайплайн и типа ми щас запустим 5 горутин и у нас виведутса цифри от нуля до четриох ну можеш бить не сразу потомучо мы синзронно запускаем и так деалее но ту и мы допускаем ошибку потомучто тут  мы функци не запускаем
```
go func() {
	fmt.Println(i)
}()

```

### мы вего лиш кладем в очередь планировщика и когда очеердь дойдет до нее - извесно только планировщику мы на это повлиять не можем/ тому пять итераций цикла прокрууться бистрее чем планировщик созрее запустть  одну из горутин и даже если одну успееет запустить то остальние четире не успаее и получаеться что цикл заканчивееться и после него мы не умеием ничего  а поскольку main являетса точной входа в програму (енкрипоин) и когда он завершаетса то собственно у убиваеться процес. а если процес убиваться  всі дочірні його елементи ( горутини) тоже завертаються. то програмав нас завершиться  и остальнь горутини нічого не наркують

```

func main() {
	for i := 0; i < 5; i++ {
		go func() {
			fmt.Println(i)
		}()
	}

	time.Sleep(time.Second)
}

func main() {
	for i := 0; i < 5; i++ {
		go func() {
			fmt.Println(i)
		}()
	}

	time.Sleep(time.Minute)
}

```

### тут ми можемо поставив тайм сліп, але в деяких випадках він може бути не достаній або збиточним для того, що вісити до тих пір пока не завершиться горутина прелумали вейт групу у вейт групу є три базоивих метота 

*** ед - добавить щочику інкрементить. В ед ми добаваляється на скільки збільнить
*** доне - декрментить щотчик( зменчуж еденицу) в дан ми нічого не пропусуємо, дан завжди на одниницю зменшує
*** вейт - при кожній ітеграціїзбільшух щоткік вайт грпу на одиницю

```
func main() {
	wg: sync.WaitGroup{}

	for i := 0; i < 5; i++ {

		go func() {
			wg.Add(1)

			fmt.Println(i)
			wg.Done()
		}()
	}

	wg.Wait()
}
```

вам може здатись можу вейт групу ми не запустили тут  и збільшили щотчік оскільки  він стартував,
закінчили горутину написали done/ причина в тому, що ми не знаєм коли запуститься не названі функції в горуинах
цикл пройде бисріше ніж пройде якась з горутин. щотчік буде на нулі , бо його ніхто не збільшував і вейт не заблокується
і в нас все здохне
```

func main() {
	wg: sync.WaitGroup{}
	wg.Add(1)

	for i := 0; i < 5; i++ {
		go func() {
			fmt.Println(i)
			wg.Done()
		}()
	}

	wg.Wait()
}
```

також можемо уявити витуацію  якій знаємо скільки буде ітерацій ( в данно випадку 5)
і в такому випадку код робочий, але це лише для нашого випадка, часьше логіка коду можн бути тяжча
з якись правилами, різними точками вихода і тд.
```
func main() {
	wg: sync.WaitGroup{}
	wg.Add(1)

	for i := 0; i < 5; i++ {
		go func() {
			fmt.Println(i)
			if {
				return -------- тут
			}

			if {
				return
			}

			wg.Done()
		}()
	}

	wg.Wait()
}
```

наприклад як тут, якщо ми так залишимо то ми наткнемосьна дедлок, це через те що ми тут вилітаємо і до дан просто не доходимо
і виходить так, що горутина завершиться, а щотчік не зменчиться на одниицю і ми получим блокіовку
ран тайм злобить і саже, що щотчік не ноль, а горутини всі сплять і вилетить панінка і буде дедлоек
```

func main() {
	wg: sync.WaitGroup{}

	wg.Add(5)
	for i := 0; i < 5; i++ {
		go func() {
			defer wg.Done()
			fmt.Println(i)
		}()
	}

	wg.Wait()
}
```


на домомогу нам прийде девер, консрукція девер виповнюєтсья вкінці фнкції і без рідниці закінчиься функція панікою чи чисоь іншим
дефер буде визваний. Але є пипадок при якому дефер не запуститься, як якщо ми визвемо число
процес грогнеться і дефер не визветься 
```
func main() {
	wg: sync.WaitGroup{}

	wg.Add(5)
	for i := 0; i < 5; i++ {
		go func() {
			defer wg.Done()
			fmt.Println(i)

			os.Exit(1)
			Log.Fatal()
		}()
	}

	wg.Wait()
}
```

наприклад при созроблці консольних утіліт в дефекарх можна завертать збір показатілєй: пресов, метрік. щоб локально щось відложувати
і в цілому якщр збиражмо стистику/ в такому ваипадку дефер не буде виконаний


```
func main() {
	wg: sync.WaitGroup{}

	wg.Add(5)
	for i := 0; i < 5; i++ {
		go func() {
			fmt.Println(i)
			defer wg.Done()

		}()
	}

	wg.Wait()
}
```
в даному виадку дефер буде викони тільки втому разі якщо він буде в стеці

розказать що таке стек ----

```

func main() {
	wg: sync.WaitGroup{}

	wg.Add(5)
	for i := 0; i < 5; i++ {
		go func() {
			defer.fmt.Println(i) --- другий 
			defer wg.Done() ---- перший 

		}()
	}

	wg.Wait()
}

```

можем зрлбить так, і тоді в нас буде спер виконинй дефер за порядком. але це вигляжа страноо і тупо	

```
func main() {
	wg: sync.WaitGroup{}

	wg.Add(5)
	for i := 0; i < 5; i++ {
		go func(wg *sync.WaitGroup) {
			defer wg.Done() 
			fmt.Println(i) 

		}(&wg)
	}

	wg.Wait()
}

func warszaw(wg *sync.WaitGroup) {

}
```

### ми також можемо предати аргументи, але справа в тому що ми маємо справу з замиканням. Предтавимо, що в нас є не названа функці, а щовнішня в який виконужться логіка тоді да, нам треба буде прокінуть вейт групу, але вейт групу обовязкого треба було покінуть по указатілям якщо би не прокінули про указалєтялм то вона би в нас просто скопірувалсь  і скопірувасяб той щотчік , який схований під нею i всі наші модиіуацію, визови дан і тд. вони би примінялись до копії, а оригінал на якому ми чекаєм  вейт не був би в курсі цих змін

```
func main() {
	wg: sync.WaitGroup{} --- зовнішя чатсина фун3цї

	wg.Add(5)
	for i := 0; i < 5; i++ {
		go func(wg *sync.WaitGroup) { --- в середині однієї функції
			defer wg.Done()  ---- перемінна
			fmt.Println(i) 

		}()
	}

	wg.Wait()
}
```


### але оскільки в нас функція визиваєтсья в середині функції - в нас нема потреба це все предавать, бо оскільки в нас присутнж замикання замикання це коли  в  середині однієї функції  використовуєо перемінну, яка обявленна з зовні цієї функції і ця перміна defer wg.Done() по стандарту мови захватуєтсь в середину по указатєлю, що в свю чергу ніякої копії не створює це на сдуже сильно устраює. Але у випадку  fmt.Println(i)  - нас це не устраює i - це щотік числа, який мінється в черзі всіх ітерацій це одна і так сама переменна, яка має одни і той самий адрес (і) оскліьки ми маємо тут справу з замиканням, у нас у пайплайн  прокідуєтсья іменно по указатжлю значення (і) але є нюанс - горутини почнуть запускаютсья після всіх ітерацій  і щначення по адресу (і) у нас лежить останнє і тоді але всю або частина  горутн виведет типо останнє значення щотчіка  останнє значення у цикла в даному випадку не завжди буде 4 у нас коли щотщік доходить до 4, він підкручуєт ітераіію , адьше він інрементиться  становиться 5 і тілкьи після того як він став 5  ми розуміємо зо умови циклу не виконуються  i < 5  і ухдим з цього цикла. але (і) остається 5  тому більша части горутин виведе 5 . канжшно якась горутина веведе 3 або шось інше, бо може вспіть бистріше ніж ітерацію цикла ащкінчиться. В нас є два шляхи вирішення цієї проблеми зробить копію, ми в безіменну фунцію принімаємо (і) і водить, що оце (і) е то (і), а це (і)


```
func main() {
	wg: sync.WaitGroup{} 

	wg.Add(5)
	for i := 0; i < 5; i++ { - це вже не це 
		go func(i int) {  --- а це 
			defer wg.Done() 
			fmt.Println(i)  - оце ай

		}(i)
	}
	wg.Wait()
}
```


2)

```
func main() {
	wg: sync.WaitGroup{} 

	wg.Add(5)
	for i := 0; i < 5; i++ {  
		i := i

		go func(i int) {  
			defer wg.Done() 
			fmt.Println(i)  

		}()
	}
	wg.Wait()
}
```


### ну в середині ітерації цикала створюємо локальну перемінну  з тим самим іменем і копіруємо  це щначення  і назватуєм  указатель не цієї ай for i := 0; i < 5; i++ { , а цієї  i := i

----
```
func main() {
	wg: sync.WaitGroup{} 

	wg.Add(5)
	for i := 0; i < 5; i++ {  
		go func(i int) {  
			defer wg.Done() 
			fmt.Println(i)  
		}(i)
	}
	wg.Wait()
}
```

### он в на сробочий ваірант, який виведе цифри від 0 до 4 в робочому стані с таокм увипаду ніякого оверхеду не буде на очікуванні, вейт буде вісіть пока всі горутини це завершать свою роботу

	