package main

import (
	"fmt"
	"runtime"
	"sync"
)

func main() {
	wg := sync.WaitGroup{}

	runtime.GOMAXPROCS(1)

	wg.Add(5)
	for i := range []int{1, 2, 3, 4, 5} {
		go func() {
			defer wg.Done()
			fmt.Println(i)
		}()
	}

	wg.Wait()
}


for range возвращает index, value. Если запрашиваем одну переменную, то индекс. Поэтому 0,1,2,3,4



Такое поведение (4, 0, 1, 2, 3) повторяется. У меня предположение, что горутины с 0 по 3 ставятся в локальную очередь. А горутина с 4-кой ставится в LIFO часть глобальной очереди и оттуда и исполняется первой (потому что она уже есть в кэше процессора), а уже за ней те, что локальной очереди.

Размер локальной очереди 256. А так гуглить runnext, это поле у P. Новые горутины получают приоритет, при этом используют остаток временного слота горутины-создателя. Каждый go stmt забрасывает новую горутину в runnext и шедулер возьмет сначала горутину из runnext и только потом начнет разгребать локальную очередь.